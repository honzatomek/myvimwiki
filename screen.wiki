= Contents =
    - [[#layout|layout]]
        - [[#layout#Default layout for new screen's|Default layout for new screen's]]
        - [[#layout#session with custom .screenrc|session with custom .screenrc]]
            - [[#layout#session with custom .screenrc#example|example]]
        - [[#layout#kill all detached sessions|kill all detached sessions]]

= layout =
https://superuser.com/questions/687348/how-to-persist-gnu-screen-layout-after-restart

== Default layout for new screen's ==
* Manage your regions, then execute code inside screen:
    - To save your current layout to file .screen_layout:

	{{{class="brush: bash"
	rm -f $HOME/.screen_layout
	screen -X layout dump .screen_layout
	}}}

    - To make it auto-loading with layout saving:
	{{{class="brush: bash"
	echo source .screen_layout  >> $HOME/.screenrc
	echo layout save def >> $HOME/.screenrc
	}}}

* How it works:
    1) You type screen.
    2) Screen reads _$HOME/.screenrc_:
    3) `source .screen_layout` - read and execute commands from _$HOME/.screen_layout_
       Regions now created.
    4) `layout save def` - save current regions as layout to keep it when you detach.

* `layout dump .screen_layout`
    Dump (append) current layout to file in _$HOME_ directory.

* `screen -X command`
    Run _command_ in current screen session (if executed inside).
    Similar to _<ctrl+a>_ then _:_ command.

* You may also
    - Disable copyright notice at startup:
	{{{class="brush: bash"
	echo startup_message off >> $HOME/.screenrc
	}}}

* Increase scroll buffer(def. 100)
    {{{class="brush: bash"
    echo defscrollback 1000 >> $HOME/.screenrc
    }}}

* Write own _.screen_layout_ (50% / 50% vertical, with 2 shells):
    {{{class="brush: bash"
    split -v
    screen -t s1

    focus
    screen -t s2

    focus
    }}}

== session with custom .screenrc ==
creates a new session by ${session_name} and runs custom rc file for it
{{{class="brush: bash"
screen -S "${session_name}" -c ~/.screenrc_custom
}}}

can be scripted:
* create a default .screenrc file
* create an rc file for each custom predefined session
* source the default .screenrc file inside
* create a custom layout file
* source a layout file inside, don't forget to include `layout save def` at the end of the custom rc file
* write a script that checks if a session by given name is running:
    * if running -> attach
    * if not -> create

{{{class="brush: bash"
if [[ $(screen -ls | grep "${session_name}") ]] ; then
    screen -x "${session_name}"
else
    screen -S "${session_name}" -c ~/.screenrc_custom
fi
}}}

=== example ===
* list of files:
    {{{class="brush: bash"
    .
    ├── python3/
    │   └── .screenrc_python
    ├── screenpython*
    └── .screenrc

    1 directory, 5 files
    }}}

* default *_.screenrc_*:
    {{{class="brush: bash"
    startup_message off
    defscrollback 1000

    shell /bin/bash
    }}}

* custom *_./python3/.screenrc_python_*:
    {{{class="brush: bash"
    source .screenrc

    split -v
    resize 60%
    screen -t 'edit' -X bash -c "cd ${HOME}/Programming/PYTHON3/bin/; vim"

    focus
    screen -t 'repl' -X /usr/bin/env python3

    focus

    layout save def
    }}}

* script to *start* or *attach to* a *_named session_*:
    {{{class="brush: bash"
    #!/bin/bash

    SCRIPT=$(readlink -m "$0")
    SCRIPTPATH=$(dirname "${SCRIPT}")
    SCREENRC=".screenrc"
    SESSIONRC=".screenrc_python"
    SESSIONLAYOUT=".screen_python_layout"
    SESSION='python3'

    if [[ ! -e "${HOME}/${SCREENRC}" ]] ; then
      echo -e "[\033[01;31e-\033[0m] - ${SCREENRC} missing in ${HOME}"
      echo -e "[\033[01;33ei\033[0m] - copying generic ${SCREENRC} to ${HOME}"
      cp "${SCRIPTPATH}/${SCREENRC}" "${HOME}/${SCREENRC}"
    else
      echo -e "[\033[01;32e+\033[0m] - ${SCREENRC} found in ${HOME}"
    fi

    if [[ $(screen -ls | grep "${SESSION}") ]] ; then
      screen -x "${SESSION}"
    else
      screen -S "${SESSION}" -c "${SCRIPTPATH}/${SESSION}/${SESSIONRC}"
    fi
    }}}


== kill all detached sessions ==
{{{class="brush: bash"
#!/bin/bash

screen -ls | grep Detached | cut -d. -f1 | awk '{print $1}' | xargs kill
}}}

