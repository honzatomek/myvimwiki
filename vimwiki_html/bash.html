<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="date" content="2020-06-10" scheme="YYYY-MM-DD">
        <meta name="viewport" content="width=device-width" />
        <title>bash</title>
        <link rel="stylesheet" href="./style.css" type="text/css"
         media="screen" title="no title" charset="utf-8">
        <link rel="stylesheet" href="./pygmentize.css" type="text/css"
         media="screen" title="no title" charset="utf-8">
    </head>
    <body>

<h1>Contents</h1>
<ul>
<li><a href="#SED">SED</a><ul>
<li><a href="#SED#replace%20file">replace file</a></li>
<li><a href="#SED#replace%20all%20occurences">replace all occurences</a></li>
<li><a href="#SED#extended%20regexp">extended regexp</a></li>
<li><a href="#SED#prefilter%20lines%20for%20regexp">prefilter lines for regexp</a></li>
<li><a href="#SED#command%20inside%20replace%20space">command inside replace space</a></li>
<li><a href="#SED#REGEXP">REGEXP</a></li>
<li><a href="#SED#Examples">Examples</a></li>
</ul>
</li>
<li><a href="#AWK">AWK</a><ul>
<li><a href="#AWK#match,%20group,%20substitute%20and%20if-else%20example">match, group, substitute and if-else example</a></li>
</ul>
</li>
<li><a href="#GREP">GREP</a><ul>
<li><a href="#GREP#print%20only%20matched%20string">print only matched string</a></li>
</ul>
</li>
<li><a href="#useful%20commands">useful commands</a><ul>
<li><a href="#useful%20commands#cat">cat</a></li>
<li><a href="#useful%20commands#cut">cut</a></li>
<li><a href="#useful%20commands#find">find</a></li>
<li><a href="#useful%20commands#fuser">fuser</a></li>
<li><a href="#useful%20commands#grep">grep</a></li>
<li><a href="#useful%20commands#head">head</a></li>
<li><a href="#useful%20commands#ln%20-s">ln -s</a></li>
<li><a href="#useful%20commands#readlink">readlink</a></li>
<li><a href="#useful%20commands#sed">sed</a></li>
<li><a href="#useful%20commands#tail">tail</a></li>
<li><a href="#useful%20commands#top,%20htop">top, htop</a></li>
<li><a href="#useful%20commands#xrandr">xrandr</a></li>
</ul>
</li>
</ul>
<h1>SED</h1>
<h2>replace file</h2>
<p>done with <code>-i</code> option, only for <strong>GNU SED</strong>
<code>sed -i 's/pattern/replace/' file</code></p>
<p>a file extension for the overwritten file can be specified:
<code>sed -i.bak 's/pattern/replace/' file</code></p>
<p>using temp file
<code>sed 's/pattern/replace/' file &gt; tmp.bak; mv tmp.bak file</code></p>
<h2>replace all occurences</h2>
<p>done with <code>g</code> flag
<code>sed 's/pattern/replace/g' file</code></p>
<h2>extended regexp</h2>
<p>done with either <code>-E</code> or <code>-r</code> option
<code>sed -E 's/pattern/replace/' file</code></p>
<h2>prefilter lines for regexp</h2>
<p><code>sed '/pattern/s/pattern/replace/' file</code></p>
<h2>command inside replace space</h2>
<p><code>sed -r 's/(.*CAST[^\x27]*\x27)([^\x27]*)(\x27 AS DateTime.*)/echo "\1"$(date -d"\2" "+%s")"\3"/ge' file</code></p>
<h2>REGEXP</h2>
<p>FROM: https://www.gnu.org/software/sed/manual/html_node/Regular-Expressions.html</p>
<p>To know how to use sed, people should understand regular expressions (regexp for short). A regular expression is a pattern that is matched against a subject string from left to right. Most characters are ordinary: they stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern</p>
<div class="codehilite"><pre><span></span>`The quick brown fox`
</pre></div>


<p>matches a portion of a subject string that is identical to itself. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of special characters, which do not stand for themselves but instead are interpreted in some special way. Here is a brief description of regular expression syntax as used in sed.</p>
<p><code>char</code>
A single ordinary character matches itself.</p>
<p><code>*</code></p>
<p>Matches a sequence of zero or more instances of matches for the preceding regular expression, which must be an ordinary character, a special character preceded by <code>\</code>, a <code>.</code>, a grouped regexp (see below), or a bracket expression. As a GNU extension, a postfixed regular expression can also be followed by <code>*</code>; for example, <code>a**</code> is equivalent to <code>a*</code>. POSIX 1003.1-2001 says that <code>*</code> stands for itself when it appears at the start of a regular expression or subexpression, but many nonGNU implementations do not support this and portable scripts should instead use <code>\*</code> in these contexts.</p>
<p><code>\+</code></p>
<p>As <code>*</code>, but matches one or more. It is a GNU extension.</p>
<p><code>\?</code></p>
<p>As <code>*</code>, but only matches zero or one. It is a GNU extension.</p>
<p><code>\{i\}</code></p>
<p>As <code>*</code>, but matches exactly i sequences (i is a decimal integer; for portability, keep it between 0 and 255 inclusive).</p>
<p><code>\{i,j\}</code></p>
<p>Matches between i and j, inclusive, sequences.</p>
<p><code>\{i,\}</code></p>
<p>Matches more than or equal to i sequences.</p>
<p><code>\(regexp\)</code></p>
<p>Groups the inner regexp as a whole, this is used to:
Apply postfix operators, like <code>\(abcd\)*</code>: this will search for zero or more whole sequences of ‘abcd’, while <code>abcd*</code> would search for ‘abc’ followed by zero or more occurrences of ‘d’. Note that support for <code>\(abcd\)*</code> is required by POSIX 1003.1-2001, but many non-GNU implementations do not support it and hence it is not universally portable.
Use back references (see below).</p>
<p><code>.</code></p>
<p>Matches any character, including newline.</p>
<p><code>^</code></p>
<p>Matches the null string at beginning of the pattern space, i.e. what appears after the circumflex must appear at the beginning of the pattern space.
In most scripts, pattern space is initialized to the content of each line (see How sed works). So, it is a useful simplification to think of <code>^#include</code> as matching only lines where ‘#include’ is the first thing on line—if there are spaces before, for example, the match fails. This simplification is valid as long as the original content of pattern space is not modified, for example with an s command.</p>
<blockquote>
<p><code>^</code> acts as a special character only at the beginning of the regular expression or subexpression (that is, after <code>\(</code> or <code>\|)</code>. Portable scripts should avoid <code>^</code> at the beginning of a subexpression, though, as POSIX allows implementations that treat <code>^</code> as an ordinary character in that context.</p>
</blockquote>
<p><code>$</code></p>
<p>It is the same as <code>^</code>, but refers to end of pattern space. <code>$</code> also acts as a special character only at the end of the regular expression or subexpression (that is, before <code>\)</code> or <code>\|</code>), and its use at the end of a subexpression is not portable.</p>
<p><code>[list]</code> <code>[^list]</code></p>
<p>Matches any single character in list: for example, <code>[aeiou]</code> matches all vowels. A list may include sequences like char1-char2, which matches any character between (inclusive) char1 and char2.
A leading <code>^</code> reverses the meaning of list, so that it matches any single character not in list. To include ] in the list, make it the first character (after the <code>^</code> if needed), to include - in the list, make it the first or last; to include <code>^</code> put it after the first character.</p>
<p>The characters <code>$</code>, <code>*</code>, <code>.</code>, <code>[</code>, and <code>\</code> are normally not special within list. For example, <code>[\*]</code> matches either <code>‘\’</code> or <code>‘*’</code>, because the <code>\</code> is not special here. However, strings like <code>[.ch.]</code>, <code>[=a=]</code>, and <code>[:space:]</code> are special within list and represent collating symbols, equivalence classes, and character classes, respectively, and <code>[</code> is therefore special within list when it is followed by <code>.</code>, <code>=</code>, or <code>:</code>. Also, when not in <strong>POSIXLY_CORRECT</strong> mode, special escapes like <code>\n</code> and <code>\t</code> are recognized within list. See Escapes.</p>
<p><code>regexp1\|regexp2</code></p>
<p>Matches either regexp1 or regexp2. Use parentheses to use complex alternative regular expressions. The matching process tries each alternative in turn, from left to right, and the first one that succeeds is used. It is a GNU extension.</p>
<p><code>regexp1regexp2</code></p>
<p>Matches the concatenation of regexp1 and regexp2. Concatenation binds more tightly than <code>\|</code>, <code>^</code>, and <code>$</code>, but less tightly than the other regular expression operators.</p>
<p><code>\digit</code></p>
<p>Matches the digit-th <code>\(...\)</code> parenthesized subexpression in the regular expression. This is called a back reference. Subexpressions are implicity numbered by counting occurrences of <code>\(</code> left-to-right.</p>
<p><code>\n</code></p>
<p>Matches the newline character.</p>
<p><code>\char</code></p>
<p>Matches char, where char is one of <code>$</code>, <code>*</code>, <code>.</code>, <code>[</code>, <code>\</code>, or <code>^</code>. Note that the only C-like backslash sequences that you can portably assume to be interpreted are <code>\n</code> and <code>\\</code>; in particular <code>\t</code> is not portable, and matches a ‘t’ under most implementations of sed, rather than a tab character.
Note that the regular expression matcher is greedy, i.e., matches are attempted from left to right and, if two or more matches are possible starting at the same character, it selects the longest.</p>
<h2>Examples</h2>
<p><code>‘abcdef’</code>
    Matches ‘abcdef’.</p>
<p><code>‘a*b’</code>
    Matches zero or more ‘a’s followed by a single ‘b’. For example, ‘b’ or ‘aaaaab’.</p>
<p><code>‘a\?b’</code>
    Matches ‘b’ or ‘ab’.</p>
<p><code>‘a\+b\+’</code>
    Matches one or more ‘a’s followed by one or more ‘b’s: ‘ab’ is the shortest possible match, but other examples are ‘aaaab’ or ‘abbbbb’ or ‘aaaaaabbbbbbb’.</p>
<p><code>‘.*’</code>
<code>‘.\+’</code>
    These two both match all the characters in a string; however, the first matches every string (including the empty string), while the second matches only strings containing at least one character.</p>
<p><code>‘^main.*(.*)’</code>
    This matches a string starting with ‘main’, followed by an opening and closing parenthesis. The ‘n’, ‘(’ and ‘)’ need not be adjacent.</p>
<p><code>‘^#’</code>
    This matches a string beginning with ‘#’.</p>
<p><code>‘\\$’</code>
    This matches a string ending with a single backslash. The regexp contains two backslashes for escaping.</p>
<p><code>‘\$’</code>
    Instead, this matches a string consisting of a single dollar sign, because it is escaped.</p>
<p><code>‘[a-zA-Z0-9]’</code>
    In the C locale, this matches any ASCII letters or digits.</p>
<p><code>‘[^ tab]\+’</code>
    (Here tab stands for a single tab character.) This matches a string of one or more characters, none of which is a space or a tab. Usually this means a word.</p>
<p><code>‘^\(.*\)\n\1$’</code>
    This matches a string consisting of two equal substrings separated by a newline.</p>
<p><code>‘.\{9\}A$’</code>
    This matches nine characters followed by an ‘A’.</p>
<p><code>‘^.\{15\}A’</code>
    This matches the start of a string that contains 16 characters, the last of which is an ‘A’.</p>
<h1>AWK</h1>
<h2>match, group, substitute and if-else example</h2>
<p>had to install GNU AWK (<code>gawk</code>), Raspbian is preinstalled with <code>mawk</code>:</p>
<div class="codehilite"><pre><span></span>GNU Awk <span class="m">4</span>.2.1, API: <span class="m">2</span>.0 <span class="o">(</span>GNU MPFR <span class="m">4</span>.0.2, GNU MP <span class="m">6</span>.1.2<span class="o">)</span>
Copyright <span class="o">(</span>C<span class="o">)</span> <span class="m">1989</span>, <span class="m">1991</span>-2018 Free Software Foundation.

This program is free software<span class="p">;</span> you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation<span class="p">;</span> either version <span class="m">3</span> of the License, or
<span class="o">(</span>at your option<span class="o">)</span> any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY<span class="p">;</span> without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License <span class="k">for</span> more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see http://www.gnu.org/licenses/.
</pre></div>


<p>oneliner:</p>
<div class="codehilite"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="k">for</span> f in ~/vimwiki/vimwiki_html/*.html<span class="p">;</span> <span class="k">do</span>
<span class="c1">#   cat &quot;${f}&quot; | awk &#39;match($0, /(^.*&lt;a href=\&quot;)(#.*)(\&quot;&gt;.*$)/, arr) { gsub(/ /, &quot;%20&quot;, arr[2]); gsub(/\.html$/, &quot;&quot;, arr[2]); gsub(/\.md/, &quot;&quot;, arr[2]); print arr[1] arr[2] arr[3] }&#39;</span>
  cat <span class="s2">&quot;</span><span class="si">${</span><span class="nv">f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;{ match($0, /(^.*&lt;a href=\&quot;)(#.*)(\&quot;&gt;.*$)/, arr); if (arr[2] == &quot;&quot;) print $0; else { gsub(/ /, &quot;%20&quot;, arr[2]); gsub(/\.html$/, &quot;&quot;, arr[2]); gsub(/\.md/, &quot;&quot;, arr[2]); print arr[1] arr[2] arr[3] }; }&#39;</span>
<span class="k">done</span>
</pre></div>


<p>much nicer format:</p>
<div class="codehilite"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="k">for</span> f in ~/vimwiki/vimwiki_html/*.html<span class="p">;</span> <span class="k">do</span>
<span class="c1">#   cat &quot;${f}&quot; | awk &#39;match($0, /(^.*&lt;a href=\&quot;)(#.*)(\&quot;&gt;.*$)/, arr) { gsub(/ /, &quot;%20&quot;, arr[2]); gsub(/\.html$/, &quot;&quot;, arr[2]); gsub(/\.md/, &quot;&quot;, arr[2]); print arr[1] arr[2] arr[3] }&#39;</span>
  cat <span class="s2">&quot;</span><span class="si">${</span><span class="nv">f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">|</span> awk <span class="s1">&#39;</span>
<span class="s1">  {</span>
<span class="s1">    match($0, /(^.*&lt;a href=\&quot;)(#.*)(\&quot;&gt;.*$)/, arr);</span>
<span class="s1">    if (arr[2] == &quot;&quot;)</span>
<span class="s1">      print $0;</span>
<span class="s1">    else</span>
<span class="s1">      {</span>
<span class="s1">        gsub(/ /, &quot;%20&quot;, arr[2]);</span>
<span class="s1">        gsub(/\.html$/, &quot;&quot;, arr[2]);</span>
<span class="s1">        gsub(/\.md/, &quot;&quot;, arr[2]);</span>
<span class="s1">        print arr[1] arr[2] arr[3] };</span>
<span class="s1">      }&#39;</span> <span class="c1"># &gt; &quot;${f}&quot;</span>
<span class="k">done</span>
</pre></div>


<h1>GREP</h1>
<h2>print only matched string</h2>
<p><code>grep -Eo 'pattern' file</code></p>
<blockquote>
<p><code>-E</code> means extended regexp
<code>-o</code> means only matching string</p>
</blockquote>
<h1>useful commands</h1>
<h2>cat</h2>
<p>concatenate all files matching to a single file:
<code>cat *.pro &gt;&gt; profiles.txt</code></p>
<h2>cut</h2>
<p>cut delimited string (<code>-d</code>) and select 4th field (<code>-f</code>):
<code>xrandr | grep -v 'DVI\|DP\|Screen' | cut -d ' ' -f 4</code></p>
<h2>find</h2>
<p>finds all files that satisfy <code>-name</code> expression in all subfolder levels limited by <code>-maxdepth</code> and <code>-mindepth</code> (<code>-type = file</code>):
<code>find . -maxdepth 1 -mindepth 1 -type f -name "*.png"</code></p>
<h2>fuser</h2>
<p>gets user of a temporary .nfs file:
<code>fuser .nfs0000000000005eb80000172e</code></p>
<h2>grep</h2>
<p>grep multiple strings from file and export them to another:
<code>grep -E 'one|two' file.txt &gt;another_file.txt</code>
<code>grep 'one\|two' file.txt &gt;another_file.txt</code>
get matching line number:
<code>xrandr | grep -n 'DVI-I-1' | cut -d : -f 1</code></p>
<h2>head</h2>
<p>get first five lines:
<code>head -n 5 ./opt??/*.pro</code></p>
<h2>ln -s</h2>
<p>create symbolic link to a file or directory:
<code>ln -s /proj/P1144/permas/rechnungen/ ./rechnungen</code></p>
<h2>readlink</h2>
<p>writes real path of a symbolic link:
<code>readlink -f "filename"</code>
<code>readlink -f "directory"</code></p>
<h2>sed</h2>
<p>replace $CONTACT STATUS LPAT=360 with $CONTACT STATUS LPAT=5 in file statik_kompass_360.caso and export result to out:
<code>sed -e 's/$CONTACT STATUS LPAT=360/$CONTACT STATUS LPAT=5/' statik_kompass_360.caso &gt; out</code>
get common prefix of all matching files:
<code>printf "%s\n" $(find . -maxdepth 1 -mindepth 1 -type f -name "*.png") | sed -e '$!{N;s/^\(.*\).*\n\1.*$/\1\n\1/;D;}'</code></p>
<h2>tail</h2>
<p>get last 5 lines, redirect them and use grep to export lines with Elapsed to elapsed.txt:
<code>tail -n 5 ./opt??/*.pro &gt;output.txt ; grep Elapsed output.txt &gt;elapsed.txt</code>
<code>tail -n 5 ./opt??/*.pro | grep Elapsed &gt;elapsed.txt</code>
get last 5 lines, redirect to grep and search for two words:
<code>tail -n 5 ./_staangle???/*.pro | grep '_staangle\|Elapsed'</code></p>
<h2>top, htop</h2>
<p>get current running processes:
<code>top</code>
<code>htop</code></p>
<h2>xrandr</h2>
<p>get all available screen resolutions:
<code>xrandr</code>
set screen resolution to 1920x1200:
<code>xrandr -s 1920x1200</code>
list available screen resolutions (<code>-v</code> means show lines not matching):
<code>xrandr | grep -v 'DVI\|DP\|Screen'</code>
list only available screen resolutions:
<code>xrandr | grep -v 'DVI\|DP\|Screen' | cut -d ' ' -f 4</code></p>
<p><a href="index.html">back to index</a></p>

    </body>
</html>
